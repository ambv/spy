from operator import OpImpl, OpArg
from unsafe import gc_alloc, ptr

@blue
def ArrayData(DTYPE):
    @struct
    class _ArrayData:
        length: i32
        capacity: i32
        items: ptr[DTYPE]

    return _ArrayData

@blue
def ndarray1(DTYPE):

    @typelift
    class ndarray:
        __ll__: ptr[ArrayData(DTYPE)]

        def __new__(cls: type, length: i32) -> ndarray:
            data = gc_alloc(ArrayData(DTYPE))(1)
            data.length = length
            data.capacity = length
            data.items = gc_alloc(DTYPE)(length)
            i = 0
            while i < length:
                #data.items[i] = 0
                i = i + 1
            return ndarray.__lift__(data)

        @blue
        def __CALL_METHOD__(v_self: OpArg, v_meth: OpArg,
                            v_arg: OpArg) -> OpImpl:

            if v_meth.blueval == 'append':

                def append(arr: ndarray, value: DTYPE) -> void:
                    ll = arr.__ll__
                    if ll.length >= ll.capacity:
                        # resize needed - double the capacity
                        new_capacity = ll.capacity * 2
                        if new_capacity == 0:
                            new_capacity = 1
                        new_items = gc_alloc(DTYPE)(new_capacity)
                        # copy existing items
                        i = 0
                        while i < ll.length:
                            new_items[i] = ll.items[i]
                            i = i + 1
                        ll.items = new_items
                        ll.capacity = new_capacity

                    ll.items[ll.length] = value
                    ll.length = ll.length + 1

                return OpImpl(append, [v_self, v_arg])

            else:
                # XXX, it should be OpImpl.NULL but we don't have it at
                # applevel
                return None


        @blue
        def __GETITEM__(v_arr: OpArg, v_i: OpArg) -> OpImpl:

            def getitem(arr: ndarray, i: i32) -> DTYPE:
                ll = arr.__ll__
                if i >= ll.length:
                    print('IndexError')
                    # raise...
                return ll.items[i]

            return OpImpl(getitem, None)


        @blue
        def __SETITEM__(v_arr: OpArg, v_i: OpArg, v_v: OpArg) -> OpImpl:

            def setitem(arr: ndarray, i: i32, v: DTYPE) -> void:
                ll = arr.__ll__
                if i >= ll.length:
                    print("IndexError")
                    # raise...
                ll.items[i] = v

            return OpImpl(setitem, None)

    return ndarray


def main() -> void:
    a_floats = ndarray1(f64)(10)
    a_ints = ndarray1(i32)(4)
    a_ints[0] = 1
    a_ints[1] = 2
    a_ints[2] = 3
    a_ints[3] = 4
    a_ints.append(5)
    a_ints.append(6)
    i = 0
    while i < 6:
        print(a_ints[i])
        i = i + 1
